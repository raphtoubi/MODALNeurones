#include <iostream>
#include <assert.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <tensorflow/c/c_api.h>

using namespace std;

enum SaveOrRestore { SAVE, RESTORE };

int DirectoryExists(const char* dirname) {
    struct stat buf;
    return stat(dirname, &buf) == 0;
}



class Model {
public:
    
    TF_Graph* graph;
    TF_Session* session;
    TF_Status* status;
    TF_Output input, target, output;
    TF_Operation *init_op, *train_op, *save_op, *restore_op;
    TF_Output checkpoint_file;
    
    Model(const char* graph_def_filename){
        this->status = TF_NewStatus();
        this->graph = TF_NewGraph();
        {
          
            // Create the session.
            TF_SessionOptions* opts = TF_NewSessionOptions();
            this->session = TF_NewSession(this->graph, opts, this->status);
            TF_DeleteSessionOptions(opts);
            assert(Okay(this->status));
        }
        TF_Graph* g = this->graph;
        {
          
            // Import the graph.
            TF_Buffer* graph_def = ReadFile(graph_def_filename);
            if (graph_def == nullptr) exit(EXIT_FAILURE);
            printf("Read GraphDef of %zu bytes\n", graph_def->length);
            TF_ImportGraphDefOptions* opts = TF_NewImportGraphDefOptions();
            TF_GraphImportGraphDef(g, graph_def, opts, this->status);
            TF_DeleteImportGraphDefOptions(opts);
            TF_DeleteBuffer(graph_def);
            assert(Okay(this->status));
        }
    }
    
    void Init() {
        const TF_Operation* init_op[1] = {this->init_op};
        TF_SessionRun(this->session, nullptr,
        /* No inputs */
        nullptr, nullptr, 0,
        /* No outputs */
        nullptr, nullptr, 0,
        /* Just the init operation */
        init_op, 1,
        /* No metadata */
        nullptr, this->status);
        assert( Okay(this->status));
    }
    
    void Predict(float* batch, int batch_size) {
        // batch consists of 1x1 matrices.
        const int64_t dims[3] = {batch_size, 1, 1};
        const size_t nbytes = batch_size * sizeof(float);
        TF_Tensor* t = TF_AllocateTensor(TF_FLOAT, dims, 3, nbytes);
        memcpy(TF_TensorData(t), batch, nbytes);
        TF_Output inputs[1] = {this->input};
        TF_Tensor* input_values[1] = {t};
        TF_Output outputs[1] = {this->output};
        TF_Tensor* output_values[1] = {nullptr};
        TF_SessionRun(this->session, nullptr, inputs, input_values, 1, outputs,
                      output_values, 1,
        /* No target operations to run */
                        nullptr, 0, nullptr, this->status);
        TF_DeleteTensor(t);
        assert(Okay(this->status));
        if (TF_TensorByteSize(output_values[0]) != nbytes) {
            cerr << "ERROR: Expected predictions tensor to have" << nbytes << "bytes, has" << TF_TensorByteSize(output_values[0]) << endl;
            TF_DeleteTensor(output_values[0]);
            exit(EXIT_FAILURE);
         }
        float* predictions = (float*)malloc(nbytes);
        memcpy(predictions, TF_TensorData(output_values[0]), nbytes);
        TF_DeleteTensor(output_values[0]);
        printf("Predictions:\n");
        for (int i = 0; i < batch_size; ++i) {
            printf("\t x = %f, predicted y = %f\n", batch[i], predictions[i]);
        }
        free(predictions);
    }
    
    void RunTrainStep(TF_Tensor* input_batch,
                      TF_Tensor* target_batch) {
        
        TF_Output inputs[2] = {this->input, this->target};
        TF_Tensor* input_values[2] = {input_batch, target_batch};
        const TF_Operation* train_op[1] = {this->train_op};
        TF_SessionRun(this->session, nullptr, inputs, input_values, 2,
        /* No outputs */
        nullptr, nullptr, 0, train_op, 1, nullptr, this->status);
        assert(Okay(this->status));
    }
    
    void Checkpoint(const char* checkpoint_prefix, int type) {
        TF_Tensor* t = ScalarStringTensor(checkpoint_prefix, this->status);
        if (!Okay(this->status)) {
            TF_DeleteTensor(t);
            exit(EXIT_FAILURE);
        }
        TF_Output inputs[1] = {this->checkpoint_file};
        TF_Tensor* input_values[1] = {t};
        const TF_Operation* op[1] = {type == SAVE ? this->save_op
                                                : this->restore_op};
        TF_SessionRun(this->session, nullptr, inputs, input_values, 1,
        /* No outputs */
        nullptr, nullptr, 0,
        /* The operation */
                    op, 1, nullptr, this->status);
        TF_DeleteTensor(t);
        assert(Okay(this->status));
    }
    
    void Destroy() {
        TF_DeleteSession(this->session, this->status);
        Okay(this->status);
        TF_DeleteGraph(this->graph);
        TF_DeleteStatus(this->status);
    }
    
private:
    bool Okay(TF_Status* status) {
        if (TF_GetCode(status) != TF_OK) {
            fprintf(stderr, "ERROR: %s\n", TF_Message(status));
            return false;
        }
        return true;
    }

    
    TF_Tensor* ScalarStringTensor(const char* str, TF_Status* status) {
        size_t nbytes = 8 + TF_StringEncodedSize(strlen(str));
        TF_Tensor* t = TF_AllocateTensor(TF_STRING, nullptr, 0, nbytes);
        void* data = TF_TensorData(t);
        memset(data, 0, 8);  // 8-byte offset of first string.
        TF_StringEncode(str, strlen(str), data + 8, nbytes - 8, status);
        return t;
    }
    
    TF_Buffer* ReadFile(const char* filename) {
        int fd = open(filename, 0);
        if (fd < 0) {
            perror("failed to open file: ");
            return nullptr;
        }
        
        struct stat stat;
        if (fstat(fd, &stat) != 0) {
            perror("failed to read file: ");
            return nullptr;
        }
        char* data = (char*)malloc(stat.st_size);
        ssize_t nread = read(fd, data, stat.st_size);
        if (nread < 0) {
            perror("failed to read file: ");
            free(data);
            return nullptr;
        }
        if (nread != stat.st_size) {
            fprintf(stderr, "read %zd bytes, expected to read %zd\n", nread,
                    stat.st_size);
            free(data);
            return nullptr;
        }
        TF_Buffer* ret = TF_NewBufferFromString(data, stat.st_size);
        free(data);
        return ret;
    }

    
};


int main() {
    const char* graph_def_filename = "graph.pb";
    const char* checkpoint_prefix = "./checkpoints/checkpoint";
    int restore = DirectoryExists("checkpoints");

    printf("Loading graph");
    Model model(graph_def_filename);

    if (restore) {
        printf("Restoring weights from checkpoint (remove the checkpoints directory to reset)");
        model.Checkpoint(checkpoint_prefix, RESTORE);
    }
    else {
        printf("Initializing model weights\n");
        model.Init();
    }

    float testdata[3] = {1.0, 2.0, 3.0};
    printf("Initial predictions");
    model.Predict(&testdata[0], 3);

    printf("Training for a few steps");
    for (int i = 0; i < 200; ++i) {
        
        //Building one batch
        TF_Tensor **train_inputs, **train_targets;
        
        #define BATCH_SIZE 10
        float inputs[BATCH_SIZE] = {0};
        float targets[BATCH_SIZE] = {0};
        for (int i = 0; i < BATCH_SIZE; ++i) {
            inputs[i] = static_cast<float>(rand()) / static_cast<float>(RAND_MAX);
            targets[i] = 3 * inputs[i] + 2;
        }
        const int64_t dims[] = {BATCH_SIZE, 1, 1};
        size_t nbytes = BATCH_SIZE * sizeof(float);
        *train_inputs = TF_AllocateTensor(TF_FLOAT, dims, 3, nbytes);
        *train_targets = TF_AllocateTensor(TF_FLOAT, dims, 3, nbytes);
        memcpy(TF_TensorData(*train_inputs), inputs, nbytes);
        memcpy(TF_TensorData(*train_targets), targets, nbytes);
        #undef BATCH_SIZE
        
        model.RunTrainStep(*train_inputs, *train_targets);
    }
    

    printf("Updated predictions\n");
    model.Predict(&testdata[0], 3);
    printf("Saving checkpoint\n");
    model.Checkpoint(checkpoint_prefix, SAVE);

    model.Destroy();
}

